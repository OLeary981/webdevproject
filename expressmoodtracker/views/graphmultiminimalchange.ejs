<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Graph</title>
    <!-- Include Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Include Moment.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <!-- Include Moment.js adapter for Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">
    <link rel="stylesheet" href="/css/mystyles.css">
</head>
</head>
<body>
    <h1 class="title">Line Graph</h1>
    <!-- Container for the graph using Bulma columns -->
    <div class="columns is-centered">
        <div class="column is-half">
            <!-- Canvas element for the chart -->
            <canvas id="myChart" width="400" height="400"></canvas>
        </div>
    </div>
    <div class="buttons is-flex is-justify-content-center">
        <!-- Buttons for changing the time range -->
        <button id="allButton" class="button is-info">All Time</button>
        <button id="yearButton" class="button is-info">Year</button>
        <button id="threeMonthsButton" class="button is-info">3 Months</button>
        <button id="monthButton" class="button is-info">Month</button>
        <button id="weekButton" class="button is-info">Week</button>
    </div>
    <script>
        const emotionColorMap = {
            "enjoyment": "#E69F00",   // Orange
            "surprise": "#56B4E9",    // Sky Blue
            "contempt": "#009E73",    // Bluish Green
            "fear": "#F0E442",        // Yellow
            "sadness": "#0072B2",     // Blue
            "disgust": "#D55E00",     // Vermillion
            "anger": "#CC79A7"        // Reddish Purple
        };
    //non-working code attempting to colour the backgrounds of the cards according to emotion.
    //     function getDominantEmotions(snapshot) {
    // const levelsForDate = [
    //     snapshot.enjoyment_level,
    //     snapshot.surprise_level,
    //     snapshot.contempt_level,
    //     snapshot.sadness_level,
    //     snapshot.fear_level,
    //     snapshot.disgust_level,
    //     snapshot.anger_level
    // ];

//     const dominantEmotions = [];
//     const maxLevel = Math.max(...levelsForDate);
//     Object.keys(snapshot).forEach((emotion, index) => {
//         if (levelsForDate[index] === maxLevel) {
//             dominantEmotions.push(emotion);
//         }
//     });
//     return dominantEmotions;
// }

// // Function to generate a gradient CSS string based on dominant emotions
// function generateGradient(dominantEmotions) {
//     // Calculate color stops for gradient
//     const numEmotions = dominantEmotions.length;
//     const colorStops = dominantEmotions.map((emotion, index) => {
//         const color = emotionColorMap[emotion];
//         const position = index * (100 / (numEmotions - 1));
//         return `${color} ${position}%`;
//     });

//     // Construct gradient CSS string
//     return `linear-gradient(to right, ${colorStops.join(', ')})`;
// }

// document.addEventListener('DOMContentLoaded', () => {
//     const snapshotCards = document.querySelectorAll('.date-card');
//     snapshotCards.forEach((card, index) => {
//         const snapshot = snapshots[index]; // Assuming snapshots array is available
//         const dominantEmotions = getDominantEmotions(snapshot);
//         const gradient = generateGradient(dominantEmotions);
//         card.style.backgroundImage = gradient;
//     });
// });

document.addEventListener('DOMContentLoaded', () => {
    const snapshotCards = document.querySelectorAll('.date-card');
    snapshotCards.forEach((card) => {
        card.addEventListener('mouseover', (event) => {
            const notes = event.currentTarget.dataset.notes; // Get the notes from the data attribute
            if (notes) {
                const tooltip = document.createElement('div');
                tooltip.classList.add('tooltip');
                tooltip.textContent = notes;
                card.appendChild(tooltip);
            }
        });

        card.addEventListener('mouseout', (event) => {
            const tooltip = event.currentTarget.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        });
    });
});
    </script>
    
    <div class="container">
        <div class="uk-grid uk-child-width-1-5" uk-grid>
            <% snapshots.reverse().forEach((snapshot) => { %>
                <div>
                    <div class="uk-card uk-card-body uk-card-default date-card" data-notes="<%= snapshot.notes %>">
                        <% var formattedDate = new Date(snapshot.timestamp); %>
                        <a href="/singlesnapshot/<%= snapshot.snapshot_ID %>" class="uk-link-toggle">
                            <h3 class="uk-card-title"><%= formattedDate.toLocaleDateString('en-GB') %></h3>
                        </a>
                        <!-- Add a hidden paragraph to store the notes -->
                        <p class="notes" style="display: none;"><%= snapshot.notes %></p>
                    </div>
                </div>
            <% }); %>
        </div>
    </div>
    <script>
       

        let myChart; // Declare myChart variable in the global scope
    
        // Extracting dates and levels from EJS variables
        const dates = JSON.parse('<%- JSON.stringify(dates.map(dateObj => dateObj.timestamp)) %>');
        const levelData = JSON.parse(`<%- JSON.stringify(levels) %>`);
        const levels = levelData.map(level => level.map(levelObj => Object.values(levelObj)[0]));
        const emotionLabels = ["enjoyment", "surprise", "contempt", "sadness", "fear", "disgust", "anger"];
        console.log(`emotion labels are: ${emotionLabels}`);
    
        // Create initial chart with one week worth of data
        const defaultStartDate = moment().subtract(1, 'week');
        const filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDate));
        const filteredLevels = filteredDates.map((date, index) => levels.map(level => level[index]));
    
        // Function to create chart
        function createChart(dates, levels) {
            const datasets = levels.map((level, index) => ({
                label: emotionLabels[index],
                data: level,
                fill: false,
                borderColor: emotionColorMap[emotionLabels[index]],
                tension: 0.1
            }));
    
            const chartData = {
                labels: dates,
                datasets: datasets
            };
    
            const chartConfig = {
                type: "line",
                data: chartData,
                options: {
                    responsive: true,
                    animation: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            min: 0,
                            max: 10
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    'day': 'DD/MM/YYYY'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'right' }, // Display legend to the right of the chart
                        tooltips: { enabled: true },
                        title: {
                            display: true,
                            text: "Levels Snapshot",
                            font: { size: 20 },
                        },
                    },
                },
            };
    
            return new Chart("myChart", chartConfig);
        }
    
        
    
        // Function to change time range
        function changeTimeRange(range) {
            let filteredDates, filteredLevels;
            const currentDate = moment();
            switch (range) {
                case 'all':
                    // No filtering needed, use all data
                    filteredDates = dates;
                    filteredLevels = levels;
                    break;
                case 'year':
                    // Filter data for the last year
                    const defaultStartDateYear = currentDate.clone().subtract(1, 'year');
                    filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateYear));
                    filteredLevels = levels.map(level => level.slice(-filteredDates.length));
                    break;
                case '3months':
                    // Filter data for the last 3 months
                    const defaultStartDate3Months = currentDate.clone().subtract(3, 'months');
                    filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDate3Months));
                    filteredLevels = levels.map(level => level.slice(-filteredDates.length));
                    break;
                case 'month':
                    // Filter data for the last month
                    const defaultStartDateMonth = currentDate.clone().subtract(1, 'month');
                    filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateMonth));
                    filteredLevels = levels.map(level => level.slice(-filteredDates.length));
                    break;
                case 'week':
                    // Filter data for the last week
                    const defaultStartDateWeek = currentDate.clone().subtract(1, 'week');
                    filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateWeek));
                    filteredLevels = levels.map(level => level.slice(-filteredDates.length));
                    break;
                default:
                    break;
            }
    
            // Update chart with filtered data
            myChart.data.labels = filteredDates;
            myChart.data.datasets = filteredLevels.map((level, index) => ({
                label: emotionLabels[index].replace('_level', ''),
                data: level,
                fill: false,
                borderColor: emotionColorMap[emotionLabels[index]],
                tension: 0.1
            }));
            myChart.update();
    
            // Sort legend items based on the values of the last data points on the graph
            myChart.legend.legendItems.sort((a, b) => {
                const lastDataPointA = myChart.data.datasets[a.datasetIndex].data.slice(-1)[0];
                const lastDataPointB = myChart.data.datasets[b.datasetIndex].data.slice(-1)[0];
                return lastDataPointB - lastDataPointA;
            });
        };

         // Add event listeners to each button
    document.getElementById("allButton").addEventListener("click", function() {
        changeTimeRange("all");
    });

    document.getElementById("yearButton").addEventListener("click", function() {
        changeTimeRange("year");
    });

    document.getElementById("threeMonthsButton").addEventListener("click", function() {
        changeTimeRange("3months");
    });

    document.getElementById("monthButton").addEventListener("click", function() {
        changeTimeRange("month");
    });

    document.getElementById("weekButton").addEventListener("click", function() {
        changeTimeRange("week");
    });
    
        window.onload = function () {
            myChart = createChart(filteredDates, filteredLevels); // Initialize chart
            changeTimeRange('week'); // Set default time range
        };



        


    </script>
    
</body>
</html>
