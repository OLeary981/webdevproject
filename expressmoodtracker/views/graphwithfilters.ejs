<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Graph</title>
    <!-- Include Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Include Moment.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <!-- Include Moment.js adapter for Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">
    <link rel="stylesheet" href="/css/mystyles.css">
</head>
</head>
<body>
    <%- include('navbar', { isLoggedIn }) %>
    <section class="section">
        <div class="container">
    <h1 class="title">Emotion Snapshot Overview</h1>
</div>        
</section>
    <!-- Container for the graph using Bulma columns -->
    <div class="columns is-centered">
        <div class="column is-half is-centered">
            <!-- Canvas element for the chart -->
            <canvas id="myChart" ></canvas>
        </div>
    </div>
    <div class="buttons is-flex is-justify-content-center">
        <!-- Buttons for changing the time range -->
        <button id="allButton" class="button mybutton">All Time</button>
        <button id="yearButton" class="button mybutton">Year</button>
        <button id="threeMonthsButton" class="button mybutton">3 Months</button>
        <button id="monthButton" class="button mybutton">Month</button>
        <button id="weekButton" class="button mybutton">Week</button>
        <button id="dayButton" class="button mybutton">Day</button>
    </div>
    <div class="buttons is-flex is-justify-content-center">
        <button id="showAllButton" class="button mybutton">Show All</button>
        <button id="showEnjoymentButton" class="button enjoyment">Enjoyment</button>
        <button id="showSurpriseButton" class="button surprise">Surprise</button>
        <button id="showContemptButton" class="button contempt">Contempt</button>
        <button id="showFearButton" class="button fear">Fear</button>
        <button id="showSadnessButton" class="button sadness">Sadness</button>
        <button id="showDisgustButton" class="button disgust">Disgust</button>
        <button id="showAngerButton" class="button anger">Anger</button>
    </div>

    <script>
        // const emotionColorMap = {
        //     "enjoyment": "#E69F00",   // Orange
        //     "surprise": "#56B4E9",    // Sky Blue
        //     "contempt": "#009E73",    // Bluish Green
        //     "fear": "#F0E442",        // Yellow
        //     "sadness": "#0072B2",     // Blue
        //     "disgust": "#D55E00",     // Vermillion
        //     "anger": "#CC79A7"        // Reddish Purple
        // };
    //non-working code attempting to colour the backgrounds of the cards according to emotion.
    //     function getDominantEmotions(snapshot) {
    // const levelsForDate = [
    //     snapshot.enjoyment_level,
    //     snapshot.surprise_level,
    //     snapshot.contempt_level,
    //     snapshot.sadness_level,
    //     snapshot.fear_level,
    //     snapshot.disgust_level,
    //     snapshot.anger_level
    // ];

//     const dominantEmotions = [];
//     const maxLevel = Math.max(...levelsForDate);
//     Object.keys(snapshot).forEach((emotion, index) => {
//         if (levelsForDate[index] === maxLevel) {
//             dominantEmotions.push(emotion);
//         }
//     });
//     return dominantEmotions;
// }

// // Function to generate a gradient CSS string based on dominant emotions
// function generateGradient(dominantEmotions) {
//     // Calculate color stops for gradient
//     const numEmotions = dominantEmotions.length;
//     const colorStops = dominantEmotions.map((emotion, index) => {
//         const color = emotionColorMap[emotion];
//         const position = index * (100 / (numEmotions - 1));
//         return `${color} ${position}%`;
//     });

//     // Construct gradient CSS string
//     return `linear-gradient(to right, ${colorStops.join(', ')})`;
// }

// document.addEventListener('DOMContentLoaded', () => {
//     const snapshotCards = document.querySelectorAll('.date-card');
//     snapshotCards.forEach((card, index) => {
//         const snapshot = snapshots[index]; // Assuming snapshots array is available
//         const dominantEmotions = getDominantEmotions(snapshot);
//         const gradient = generateGradient(dominantEmotions);
//         card.style.backgroundImage = gradient;
//     });
// });

document.addEventListener('DOMContentLoaded', () => {
    const snapshotCards = document.querySelectorAll('.date-card');
    snapshotCards.forEach((card) => {
        card.addEventListener('mouseover', (event) => {
            const notes = event.currentTarget.dataset.notes; // Get the notes from the data attribute
            if (notes) {
                const tooltip = document.createElement('div');
                tooltip.classList.add('tooltip');
                tooltip.textContent = notes;
                card.appendChild(tooltip);
            }
        });

        card.addEventListener('mouseout', (event) => {
            const tooltip = event.currentTarget.querySelector('.tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        });
    });
});
    </script>
    
    <div class="container">
        <div class="uk-grid uk-child-width-1-5" uk-grid>
            <% snapshots.reverse().forEach((snapshot) => { %>
                <div>
                    <div class="uk-card uk-card-body uk-card-default date-card" data-notes="<%= snapshot.notes %>">
                        <% var formattedDate = new Date(snapshot.timestamp); %>
                        <a href="/singlesnapshot/<%= snapshot.snapshot_ID %>" class="uk-link-toggle">
                            <p><%= formattedDate.toLocaleDateString('en-GB') %></p>
                        </a>
                        <!-- Add a hidden paragraph to store the notes -->
                        <p class="notes" style="display: none;"><%= snapshot.notes %></p>
                    </div>
                </div>
            <% }); %>
        </div>
    </div>
    <script>
       const emotionColorMap = {
            "enjoyment": "#E69F00",   // Orange
            "surprise": "#56B4E9",    // Sky Blue
            "contempt": "#009E73",    // Bluish Green
            "fear": "#F0E442",        // Yellow
            "sadness": "#0072B2",     // Blue
            "disgust": "#D55E00",     // Vermillion
            "anger": "#CC79A7"        // Reddish Purple
        };

        let myChart; // Declare myChart variable in the global scope
    
        // Extracting dates and levels from EJS variables
        const dates = JSON.parse('<%- JSON.stringify(dates.map(dateObj => dateObj.timestamp)) %>');
        const levelData = JSON.parse(`<%- JSON.stringify(levels) %>`);
        const levels = levelData.map(level => level.map(levelObj => Object.values(levelObj)[0]));
        const levelNames = levelData.map(level => Object.keys((level)[0])[0].replace('_level', ''));
        console.log(`Level names from the start of the code ${levelNames}`);
        const emotionLabels = ["enjoyment", "surprise", "contempt", "sadness", "fear", "disgust", "anger"];
        let timeRange = 'week'; // Default time range
        let selectedSeries = null;
        let xAxisUnit='day';
        let currentDate = moment();
        
        console.log(`emotion labels are: ${emotionLabels}`);
    
        // Create initial chart with one week worth of data
        let defaultStartDate = moment().subtract(1, 'week');
        let filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDate));
        let filteredLevels = filteredDates.map((date, index) => levels.map(level => level[index]));
    
        // Function to create chart
        function createChart(dates, levels, selectedSeries, xAxisUnit) {
            //console.log("at the createChart destroy call");
        
            
    //destroyChart(myChart);
    

            console.log("Making a chart");
            console.log(`levels on chart creation ${levels}`);
            console.log(`inside create chart, selected series is: ${selectedSeries}`);
    const datasets = levels.map((level, index) => {
        //const datasetLabel = levelNames[index]; // Use levelNames instead of emotionLabels
        console.log(`datasetLabel is :${levelNames[index]}`);

        if (selectedSeries && levelNames[index] !== selectedSeries) {
            console.log("in the top if statement")
            return  {
                label: levelNames[index],
                data: [],
                fill: false,
                borderColor: 'rgba(0, 0, 0, 0)',
                tension: 0.1
            };;
        } else  {
            console.log("in the bottom if statement");
            return {
                label: levelNames[index],
                data: level,
                fill: false,
                borderColor: emotionColorMap[levelNames[index]],
                tension: 0.1
            };
        }
    });

    console.log("Datasets:", datasets.data);

    const chartData = {
        labels: dates,
        datasets: datasets
    };

    console.log(`Just before chart config the chart data datasets are:`, chartData.datasets);
    const chartConfig = {
        type: "line",
        data: chartData,
        options: {
            responsive: true,
            animation: true,
            maintainAspectRatio: true,
            scales: {
                y: {
                    min: 0,
                    max: 10
                },
                x: {
                    type: 'time',
                    time: {
                        unit: xAxisUnit,
                        displayFormats: {
                            'day': 'DD/MM/YYYY'
                        }
                    }
                }
            },
            plugins: {
                legend: { display: true, position: 'right' },
                tooltips: { enabled: true },
                title: {
                    display: true,
                    text: "Levels Snapshot",
                    font: { size: 20 },
                },
            },
            onResize: function(chart, size) {
                if (size.width !== chart.width || size.height !== chart.height) {
                    chart.resize();
                }
            }
        },
    };

console.log(`Just before chart creation the chart data is:`, chartConfig.data.datasets);

const newChart = new Chart("myChart", chartConfig);

//Sort legend labels after creating the chart - may be broken at the moment.
newChart.legend.legendItems.sort((a, b) => {
    const datasetA = newChart.data.datasets[a.datasetIndex];
    const datasetB = newChart.data.datasets[b.datasetIndex];

    // Get the last data points from datasets A and B
    const lastDataPointA = datasetA.data[datasetA.data.length - 1];
    const lastDataPointB = datasetB.data[datasetB.data.length - 1];

    // Compare the last data points
    return lastDataPointB - lastDataPointA;
});

console.log("About to return new chart");
return newChart;
}

function downsampleAndComputeRollingAverages(data, targetPoints, windowSize) {
    const downsampledData = downsample(data, targetPoints);
    const rollingAverages = computeRollingAverages(downsampledData, windowSize);
    return rollingAverages;
}

function downsample(data, targetPoints) {
    const dataSize = data.length;
    const step = Math.ceil(dataSize / targetPoints);
    const downsampledData = [];
    for (let i = 0; i < dataSize; i += step) {
        const chunk = data.slice(i, i + step);
        const avg = chunk.reduce((acc, val) => acc + val, 0) / chunk.length;
        downsampledData.push(avg);
    }
    return downsampledData;
}

function downsampleDates(dates, targetPoints) {
    const dataSize = dates.length;
    const step = Math.ceil(dataSize / targetPoints);
    const downsampledDates = [];
    for (let i = 0; i < dataSize; i += step) {
        downsampledDates.push(dates[i]);
    }
    return downsampledDates;
}

function computeRollingAverages(data, windowSize) {
    const rollingAverages = [];
    for (let i = 0; i < data.length; i++) {
        let sum = 0;
        let count = 0;
        // Compute the sum of data points within the window
        for (let j = Math.max(0, i - windowSize + 1); j <= i; j++) {
            sum += data[j];
            count++;
        }
        // Compute the average and push it to the rollingAverages array
        rollingAverages.push(sum / count);
    }
    return rollingAverages;
}
    
function updateChart(timeRange, selectedSeries, xAxisUnit) {
    
    destroyChart(myChart);
    
    // Filter dates and levels based on the selected time range
    let filteredDates, filteredLevels, targetPoints, windowSize;
    console.log("at the beginning of update chart");
    console.log(selectedSeries);
    
    switch (timeRange) {
        case 'all':
            // Use all data
            filteredDates = dates;
            filteredLevels = levels;
            targetPoints = 50; // Specify the target number of data points after downsampling
            windowSize = Math.ceil(filteredDates.length / targetPoints); // Adjust the window size based on the target number of data points
            filteredLevels = levels.map(level => downsampleAndComputeRollingAverages(level, targetPoints, windowSize));
            // Downsample the dates array after computing rolling averages
            filteredDates = downsampleDates(filteredDates, targetPoints);
            break;
        case 'year':
            // Filter data for the last year
            const defaultStartDateYear = currentDate.clone().subtract(1, 'year');
            filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateYear));
            targetPoints = 50; // Specify the target number of data points after downsampling
            windowSize = Math.ceil(filteredDates.length / targetPoints); // Adjust the window size based on the target number of data points
            filteredLevels = levels.map(level => downsampleAndComputeRollingAverages(level, targetPoints, windowSize));
            // Downsample the dates array after computing rolling averages
            filteredDates = downsampleDates(filteredDates, targetPoints);


            break;
        case '3months':
            // Filter data for the last 3 months
            const defaultStartDate3Months = currentDate.clone().subtract(3, 'months');
            filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDate3Months));
            targetPoints = 30; // Specify the target number of data points after downsampling
            windowSize = Math.ceil(filteredDates.length / targetPoints); // Adjust the window size based on the target number of data points
            filteredLevels = levels.map(level => downsampleAndComputeRollingAverages(level, targetPoints, windowSize));
            // Downsample the dates array after computing rolling averages
            filteredDates = downsampleDates(filteredDates, targetPoints);
            break;
        case 'month':
            // Filter data for the last month
            const defaultStartDateMonth = currentDate.clone().subtract(1, 'month');
            filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateMonth));           
            targetPoints = 30; // Specify the target number of data points after downsampling
            windowSize = Math.ceil(filteredDates.length / targetPoints); // Adjust the window size based on the target number of data points
            filteredLevels = levels.map(level => downsampleAndComputeRollingAverages(level, targetPoints, windowSize));
            // Downsample the dates array after computing rolling averages
            filteredDates = downsampleDates(filteredDates, targetPoints);
            break;
        case 'week':
            // Filter data for the last week
            const defaultStartDateWeek = currentDate.clone().subtract(1, 'week');
            filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateWeek));
            targetPoints = 14; // Specify the target number of data points after downsampling
            windowSize = Math.ceil(filteredDates.length / targetPoints); // Adjust the window size based on the target number of data points
            filteredLevels = levels.map(level => downsampleAndComputeRollingAverages(level, targetPoints, windowSize));
            // Downsample the dates array after computing rolling averages
            filteredDates = downsampleDates(filteredDates, targetPoints);
            break;
            case 'day':
            // Filter data for the last week
            const defaultStartDateDay = currentDate.clone().startOf('day');
            filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateDay));
            filteredLevels = levels.map(level => level.slice(-filteredDates.length));
            break;
        default:
            break;
    }

    // Update chart with filtered data
   
    console.log("just before new chart creation");
    myChart = createChart(filteredDates, filteredLevels, selectedSeries, xAxisUnit);
    console.log("near the bottom of update chart");
   

    // Update chart data
//     myChart.data.labels = filteredDates;
// myChart.data.datasets = filteredLevels.map((level, index) => {
//     //const datasetLabel = Object.keys(levelData[index])[0].replace('_level', '');
//     return {
//         label: levelNames[index],
//         data: level,
//         fill: false,
//         borderColor: emotionColorMap[levelNames[index]],
//         tension: 0.1
//     };
//});
    //myChart.update();

    // Sort legend items based on the values of the last data points on the graph
    return myChart;
}

function destroyChart(chartInstance) {
    // console.log("inside destroy method")
    // if (chartInstance instanceof Chart) {
    //     console.log("chart deteceted and inside destroy part of if statement");
    //     chartInstance.destroy();
    //     console.log("Chart destroyed successfully.");
    // } else {
    //     console.log("No chart instance found.");
    //}
    const existingChart = Chart.getChart(chartInstance);

// Destroy the existing chart if it exists
if (existingChart) {
    existingChart.destroy();
}
    
}



// Usage example
const defaultStartDateYear = currentDate.clone().subtract(1, 'year');
filteredDates = dates.filter(date => moment(date).isSameOrAfter(defaultStartDateYear));

const targetPoints = 20; // Specify the target number of data points after downsampling
const windowSize = Math.ceil(filteredDates.length / targetPoints); // Adjust the window size based on the target number of data points

filteredLevels = levels.map(level => downsampleAndComputeRollingAverages(level, targetPoints, windowSize));




         // Add event listeners to each button
    document.getElementById("allButton").addEventListener("click", function() {
        updateChart("all", selectedSeries, xAxisUnit);
    });

    document.getElementById("yearButton").addEventListener("click", function() {
        timeRange = "year"
         xAxisUnit = 'day'
        updateChart(timeRange, selectedSeries, xAxisUnit);
    });

    document.getElementById("threeMonthsButton").addEventListener("click", function() {
        timeRange = "3months"
        xAxisUnit = 'day'
        updateChart(timeRange, selectedSeries, xAxisUnit);
    });

    document.getElementById("monthButton").addEventListener("click", function() {
        timeRange = "month"
        xAxisUnit = 'day'
        updateChart(timeRange, selectedSeries, xAxisUnit);
    });

    document.getElementById("weekButton").addEventListener("click", function() {
        timeRange = "week"
        xAxisUnit = 'day'
        updateChart(timeRange, selectedSeries, xAxisUnit);
    });
    document.getElementById("dayButton").addEventListener("click", function() {
        timeRange = "day"
        xAxisUnit = 'hour'
        updateChart(timeRange, selectedSeries,xAxisUnit);
    });

    document.getElementById("showAllButton").addEventListener("click", function() {
        selectedSeries = null;
        updateChart(timeRange, selectedSeries, xAxisUnit); 
    });

    document.getElementById("showFearButton").addEventListener("click", function() {
    selectedSeries = "fear";
    updateChart(timeRange, selectedSeries,xAxisUnit);
});

document.getElementById("showAngerButton").addEventListener("click", function() {
    selectedSeries = "anger";
    updateChart(timeRange, selectedSeries,xAxisUnit);
});

document.getElementById("showDisgustButton").addEventListener("click", function() {
    selectedSeries = "disgust";
    updateChart(timeRange, selectedSeries, xAxisUnit);
});

document.getElementById("showSadnessButton").addEventListener("click", function() {
    selectedSeries = "sadness";
    updateChart(timeRange, selectedSeries, xAxisUnit);
});

document.getElementById("showContemptButton").addEventListener("click", function() {
    selectedSeries = "contempt";
    updateChart(timeRange, selectedSeries, xAxisUnit);
});

document.getElementById("showSurpriseButton").addEventListener("click", function() {
    selectedSeries = "surprise";
    updateChart(timeRange, selectedSeries, xAxisUnit);
});

document.getElementById("showEnjoymentButton").addEventListener("click", function() {
    selectedSeries = "enjoyment";
    updateChart(timeRange, selectedSeries, xAxisUnit);
});
    
        window.onload = function () {
            myChart = createChart(filteredDates, filteredLevels, selectedSeries); // Initialize chart
            updateChart(timeRange, selectedSeries, xAxisUnit); // Set default time range
        };



        


    </script>
    
</body>
</html>
